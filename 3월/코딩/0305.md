# 240305

### 프로그래머스 - **징검다리 건너기**

---

### **문제 설명**

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 **징검다리**가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

- 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
- 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
- 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.

"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

### **[제한사항]**

- 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
- stones 배열의 크기는 1 이상 200,000 이하입니다.
- stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
- k는 1 이상 stones의 길이 이하인 자연수입니다.

---

### **[입출력 예]**

| stones | k | result |
| --- | --- | --- |
| [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] | 3 | 3 |

### **입출력 예에 대한 설명**

---

**입출력 예 #1**

첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/LuBly/TIL/assets/48556414/cc4a481e-a805-4ec2-8cde-3c6a56a528b9)

첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/LuBly/TIL/assets/48556414/bccdb5ca-e301-4863-a8b8-eb30e0b08d55)

두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/LuBly/TIL/assets/48556414/0431b326-5433-4071-854a-2f9acc0a53f3)

세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.

![image](https://github.com/LuBly/TIL/assets/48556414/18d4c37c-1c7c-4c25-84c7-cccb89edd37f)

따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.

- 문제 풀이
    1. 무작정 체크
        1. 직접 친구들을 이동시키면서 몇명까지 건널 수 있을지 파악해보고자 함
        2. 직접 이동시키는 경우 최대 200,000길이인 stone을 5번만 반복하더라도 시간초과
    2. 그리디적 접근
        1. k길이 만큼만 체크
        2. 해당 범위 내의 돌이 모두 0이 된다면 건널 수 없음을 활용
        3. 모든 범위를 체크해서 범위 내의 돌이 모두 0이 되는 최소값을 찾기
            
            <aside>
            💡 ex)
            [5] (2 4 5) 3 2 1 4 2 5 1

            [5] 2 (4 5 3) 2 1 4 2 5 1

            [5] 2 4 (5 3 2) 1 4 2 5 1

            [3] 2 4 5 (3 2 1) 4 2 5 1 <<

            [4] 2 4 5 3 (2 1 4) 2 5 1

            [4] 2 4 5 3 2 (1 4 2) 5 1

            [5] 2 4 5 3 2 1 (4 2 5) 1

            [5] 2 4 5 3 2 1 4 (2 5 1)
            
            </aside>
            
        4. 다만 위의 경우 O((stone.size() - k) * k) 로 stone의 길이 200,000, k = 100,000만 되어도 시간 초과
    3. 큰 수를 체크하는데 사용하기 용이한 이분 탐색 (reference 참고)
        1. 건널 수 있는 학생 수를 기준으로 체크
        2. left 1, right stone의 max값을 기준으로 체크
            
            <aside>
            💡 
            • 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.
            
            위 조건으로 인해 앞선 학생들이 무조건 정해진 룰대로 돌을 밟고 지나가야 함
            
            </aside>
            
        3. 건널 수 있는지 없는지 체크
            1. 건널 수 있을 때 
                1. 결과 값 저장
                2. 더 건널 수 있을지 확인 ⇒ left = mid + 1
            2. 건널 수 없을 때
                1. 어디까지 건널 수 없는지 확인 ⇒ right = mid - 1
        4. 위 과정을 left > right일 때까지 반복
